# Introduction (2023/02/04)

My name's Jason, and I'm primarily a backend developer.
I've worked a little bit in the past on existing websites, but I've never built
a full one from the ground up before; that has always been a bit of a blind spot for me.
I also _really_ like developing in Rust, so I think this is a good opportunity for me to
try something I haven't done - build a website using only Rust, HTML, and CSS.

## Initial features
I want to scope the initial rollowut down to a set of easier tasks. Broad-strokes, they are as follows:

- Have a homepage with a small introduction
- Have a blog section, where I can post these writeups
- Allow Markdown blog posts so I don't need to write these in HTML
- Light styling so that things look nice

The site will start as a static page, and all blog posts will be downloaded on page load.

## Stretch goals
Once the initial goals are complete, it might make sense to implement these features:

- Host blog posts on the server and pull when requested
- Add blog previews to the blog page

After I accomplish these goals, I'll use the site as a playground to experiment with some Rust/WASM apps.

## Implementing website scaffolding
I opted to use the `leptos` framework for building the website. I didn't put too much thought into why to 
use this framework over something like `yew` or `egui`, other than that it's a fairly hyped-up framework.

To get a simple header with a picture and title, it was fairly easy, but I needed to wrestle with the 
framework a bit. What I landed on was the following; let's see if it lasts.

*main.rs*:
```rust
use components::app::{App, AppProps};
use leptos::{mount_to_body, view};

mod components;

fn main() {
    _ = console_log::init_with_level(log::Level::Debug);
    console_error_panic_hook::set_once();
    mount_to_body(|cx| {
        view! { cx,
            <App/>
        }
    })
}
```

*components/app.rs*:
```rust
use leptos::{component, IntoView, view, Scope};
use crate::components::intro::{Intro, IntroProps};

#[component]
pub fn App(cx: Scope) -> impl IntoView {
    view! { cx, 
        <Intro/>
    }
}
```

*components/intro.rs*
```rust
use leptos::{component, IntoView, view, Scope};

#[component]
pub fn Intro(cx: Scope) -> impl IntoView {
    view! { cx, 
        <div class="heading">
            <img class="heading-item profile-pic" src="assets/profile_pic.jpeg"/> 
            <p class="heading heading-item"> 
                <h1> "Jason Allen" </h1>
                <span> "Backend software dev" </span>
            </p>
        </div>
    }
}
```

Let's take a look at the implementation. 

```rust
    _ = console_log::init_with_level(log::Level::Debug);
    console_error_panic_hook::set_once();
```

This section of code makes logs and panics show up in the console in the browser.

```rust
    mount_to_body(|cx| {
        view! { cx,
            <App/>
        }
    })
```

This section is interesting, and shows some of the interesting metaprogramming you can do with Rust macros.
The `view!` macro allows us to write a fully different syntax which has its own error checking determined 
by the library maintainer. We see a better example of this here:

```rust
use leptos::{component, IntoView, view, Scope};

#[component]
pub fn Intro(cx: Scope) -> impl IntoView {
    view! { cx, 
        <div class="heading">
            <img class="heading-item profile-pic" src="assets/profile_pic.jpeg"/> 
            <p class="heading heading-item">
                <h1> "Jason Allen" </h1>
                <span> "Backend software dev" </span>
            </p>
        </div>
    }
}
```

This is a more fleshed out HTML blob. Let's take a look at what happens when we `cargo build` after 
changing `<h1> "Jason Allen" </h1>` to `<h1> "Jason Allen"`.

```
   Compiling website v0.1.0 (/Users/jasonallen/dev/website)
error: close tag has no corresponding open tag
  --> src/components/intro.rs:11:13
   |
11 |             </p>
   |             ^

error: could not compile `website` due to previous error
```

This error is also visible while editing if your editor is integrated with the rust-analyzer language server.
It's not the best error, as it's not referring to the right tag, but this functionality seems interesting
nonetheless.


